<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Python十大算法之选择排序Python代码简单实现</title>
    <url>/lxb/30363e5e.html</url>
    <content><![CDATA[<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><img src="https://img-blog.csdnimg.cn/20201014210457815.gif#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">(不考虑列表元素小于1的列表,如果列表小于等于1,需要捕获异常)</span></span><br><span class="line"><span class="string">选择排序是记录最小值的下标</span></span><br><span class="line"><span class="string">先拿着一个元素进行元素对比,找到最小的元素,把这个最小的元素放到最前面,然后在从剩余的元素中继续</span></span><br><span class="line"><span class="string">寻找最小的元素,然后放在已经排序过的序列末尾</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_list</span>(<span class="params">list_</span>):</span></span><br><span class="line">    <span class="comment"># 先定义比较的轮数, 一个一个的比较,所以省去最后一次,总轮数为 元素个数减 1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(list_)<span class="number">-1</span>):</span><br><span class="line">        <span class="comment"># 定义一个最小元素的下标,(如果是降序就是最大元素的下标)</span></span><br><span class="line">        min_sub = i</span><br><span class="line">        <span class="comment"># 定义每轮的要进行比较的次数, 由于每轮比较后都会固定一个元素,所以每轮比较次数为 总元素个数减去轮次</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(len(list_) -i):</span><br><span class="line">            <span class="keyword">if</span> list_[min_sub] &gt; list_[n+i]:</span><br><span class="line">                min_sub = n+i</span><br><span class="line">        list_[i], list_[min_sub] = list_[min_sub], list_[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list_</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    list_num = [<span class="number">23</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">78</span>, <span class="number">56</span>, <span class="number">55</span>, <span class="number">77</span>, <span class="number">8</span>, <span class="number">2</span>]</span><br><span class="line">    print(sort_list(list_num))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Python 算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Python十大算法之冒泡排序python代码简单实现</title>
    <url>/lxb/4e54f701.html</url>
    <content><![CDATA[<h2 id="Python-十大算法之冒泡排序"><a href="#Python-十大算法之冒泡排序" class="headerlink" title="(Python)十大算法之冒泡排序!"></a>(Python)十大算法之冒泡排序!</h2><p><img src="https://img-blog.csdnimg.cn/20201014202514264.gif#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">冒泡排序核心:</span></span><br><span class="line"><span class="string">        两个两个数进行比较,小的放前边大的放后面（升序排序降序反之)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 定义一个函数,实现冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_the</span>(<span class="params">list_</span>):</span></span><br><span class="line">    <span class="comment"># 由于需要两个两个的进行元素比较,每次比较都会把最大的一个值放到最后面,最后一轮比较可以省去,所以需要比较的次数为列表元素总数减一</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(list_) - <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 每次进行一轮比较后,会把最大的元素放到最后,所以每轮进比较的次数为 总轮数 - 当前轮次</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range((len(list_) - <span class="number">1</span> - i)):</span><br><span class="line">        	<span class="comment"># 该排序是大的在后面, 如果需要大的在前面,把大于号改为小于号</span></span><br><span class="line">            <span class="keyword">if</span> list_[n] &gt; list_[n + <span class="number">1</span>]:</span><br><span class="line">                list_[n], list_[n + <span class="number">1</span>] = list_[n + <span class="number">1</span>], list_[n]</span><br><span class="line">    <span class="keyword">return</span> list_</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    list_num = [<span class="number">23</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">78</span>, <span class="number">56</span>, <span class="number">55</span>, <span class="number">77</span>, <span class="number">8</span>, <span class="number">2</span>]</span><br><span class="line">    print(sort_the(list_num))</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Python 算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Python装饰器代码简单实现带参数不带参数计算时间</title>
    <url>/lxb/cb3133ae.html</url>
    <content><![CDATA[<h1 id="Python装饰器代码简单实现"><a href="#Python装饰器代码简单实现" class="headerlink" title="Python装饰器代码简单实现"></a>Python装饰器代码简单实现</h1><hr>
<p>先说一说装饰器的个人理解吧</p>
<ul>
<li>装饰器就是在不改变原函数的情况下,给原函数增加一些额外的功能,装饰器本质就是一个闭包(先说这么多,以后再补充)<h2 id="不接受参数的通用装饰器"><a href="#不接受参数的通用装饰器" class="headerlink" title="不接受参数的通用装饰器"></a>不接受参数的通用装饰器</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">定义一个装饰器,这是一个不接受参数的装饰器</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="comment"># 加 *args, **kwargs 这两个参数为了能够接受参入函数的参数(你不能保证传入的函数有没有参数,以及这个传入的函数有多少个参数)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&quot;我是装饰器&quot;</span>)</span><br><span class="line">        fun = func(*args, **kwargs)</span><br><span class="line">        <span class="comment"># 最后再把传入的函数返回出去</span></span><br><span class="line">        <span class="keyword">return</span> fun</span><br><span class="line">    <span class="comment"># 这个return 很重要,装饰器就语法就是这样, 返回内部函数,其实装饰器本质就是一个闭包</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">下面是装饰器的使用</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span>():</span></span><br><span class="line">    print(<span class="string">&quot;我是一个函数&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> 执行函数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    function()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="可以接收参数的装饰器"><a href="#可以接收参数的装饰器" class="headerlink" title="可以接收参数的装饰器"></a>可以接收参数的装饰器</h2><p>我这里就写一个只接收一个参数的装饰器, 如果需要多个参数, 只需要再加上就好啦(不懂就留言评论,看到就回)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">定义一个装饰器,这是一个不接受参数的装饰器</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parameter_deco</span>(<span class="params">item</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="comment"># 加 *args, **kwargs 这两个参数为了能够接受参入函数的参数(你不能保证传入的函数有没有参数,以及这个传入的函数有多少个参数)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            print(<span class="string">&quot;我是装饰器&quot;</span>)</span><br><span class="line">            print(<span class="string">&quot;********* 我是装饰器传入的参数 %s **********&quot;</span> % item)</span><br><span class="line">            fun = func(*args, **kwargs)</span><br><span class="line">            <span class="comment"># 最后再把传入的函数返回出去</span></span><br><span class="line">            <span class="keyword">return</span> fun</span><br><span class="line">        <span class="comment"># 这个return 很重要,装饰器就语法就是这样, 返回内部函数,其实装饰器本质就是一个闭包</span></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 看到这里你是不是发现,带有参数的装饰器,就比上面那个不带参数的装饰器多了一层外部函数,外部函数用来接收参数,然后再把内层函数返回</span></span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">下面是装饰器的使用</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里就传入一个值就行(这里我传入一个字符串,这是我的个人博客网站,欢迎访问)</span></span><br><span class="line"><span class="meta">@parameter_deco(&quot;https://lxb-log.github.io/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span>():</span></span><br><span class="line">    print(<span class="string">&quot;我是一个函数&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> 执行函数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    function()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用装饰器实现测试某函数的执行时间"><a href="#使用装饰器实现测试某函数的执行时间" class="headerlink" title="使用装饰器实现测试某函数的执行时间"></a>使用装饰器实现测试某函数的执行时间</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_decorator</span>(<span class="params">func</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 执行传入的函数的开始时间</span></span><br><span class="line">        begin = time.time()</span><br><span class="line">        <span class="comment"># 执行传入的函数</span></span><br><span class="line">        fun = func(*args, **kwargs)</span><br><span class="line">        <span class="comment"># 执行传入的函数的结束时间</span></span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">&quot;该函数执行花费%s&quot;</span> % (end-begin))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fun</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里就传入一个字符串就行(这是我的个人博客网站,欢迎访问)</span></span><br><span class="line"><span class="meta">@time_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span>():</span></span><br><span class="line">    <span class="comment"># time.sleep(2) 延迟2秒,跟容易理解</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">&quot;https://lxb-log.github.io/&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> 执行函数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    function()</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python十大算法之插入排序Python代码简单实现</title>
    <url>/lxb/df95721d.html</url>
    <content><![CDATA[<h1 id="Python十大算法之插入排序Python代码简单实现"><a href="#Python十大算法之插入排序Python代码简单实现" class="headerlink" title="Python十大算法之插入排序Python代码简单实现"></a>Python十大算法之插入排序Python代码简单实现</h1><p><img src="https://img-blog.csdnimg.cn/20201017110805885.gif#pic_center" alt="在这里插入图片描述"></p>
<p><strong><code>图片上是从已排好序的元素最大坐标开始比较的, 我的代码是从已排好序的元素的最小坐标开始,一个道理的</code></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">插入排序 (个人理解)</span></span><br><span class="line"><span class="string">先假设第一个元素不动,从第二个元素开始,然后拿着第二个元素跟第一个(已经排好序的元素)进行对比,</span></span><br><span class="line"><span class="string">如果大于第一个元素就把这个元素放在第一个元素后面,现在已经排好两个元素了</span></span><br><span class="line"><span class="string">接着在拿第三个元素,跟已经排好序的元素进行对比,</span></span><br><span class="line"><span class="string">如果该元素遇到比它小的元素就放在它的后面, 以此类推</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_list</span>(<span class="params">list_</span>):</span></span><br><span class="line">    <span class="comment"># 先定义比较的轮数, 由于是从第二个元素开始的,所以轮数为 总元素个数减 1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(list_)<span class="number">-1</span>):</span><br><span class="line">        <span class="comment"># 然后再定义每轮进行比较的次数,这个次数就是已经排好序的元素个数,每轮排好一个,默认排好一个, 所以次数就是轮次加 1</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span> + i):</span><br><span class="line">            <span class="comment"># 下面开始判断条件,</span></span><br><span class="line">            <span class="keyword">if</span> list_[i+<span class="number">1</span>] &lt; list_[n]:</span><br><span class="line">                list_[i+<span class="number">1</span>], list_[n] = list_[n],  list_[i+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list_</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    list_num = [<span class="number">23</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">78</span>, <span class="number">56</span>, <span class="number">55</span>, <span class="number">77</span>, <span class="number">8</span>, <span class="number">2</span>]</span><br><span class="line">    print(sort_list(list_num))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Python 算法</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫使用的各种USER_AGENT</title>
    <url>/lxb/1bf885a0.html</url>
    <content><![CDATA[<p>下面是我写的一段代码, 调用这个函数可以随机返回一个请求头<br>USER_AGENT 就是每个浏览器的标识, 下面有手机端, 使用时注意要爬取的页面PC端跟手机端的HTML解析不同</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">用于返回一个随机的请求头</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">USER_AGENTS = [</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/19.77.34.5 Safari/537.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.0 Safari/536.3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (iPhone; U; CPU iPhone OS 4_3_3 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5&quot;</span>,</span><br><span class="line">    <span class="comment"># IPod</span></span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (iPod; U; CPU iPhone OS 4_3_3 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5&quot;</span>,</span><br><span class="line">    <span class="comment"># IPAD</span></span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (iPad; U; CPU OS 4_2_1 like Mac OS X; zh-cn) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8C148 Safari/6533.18.5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (iPad; U; CPU OS 4_3_3 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5&quot;</span>,</span><br><span class="line">    <span class="comment"># Android</span></span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Linux; U; Android 2.2.1; zh-cn; HTC_Wildfire_A3333 Build/FRG83D) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Linux; U; Android 2.3.7; en-us; Nexus One Build/FRF91) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1&quot;</span>,</span><br><span class="line">    <span class="comment"># QQ浏览器 Android版本</span></span><br><span class="line">    <span class="string">&quot;MQQBrowser/26 Mozilla/5.0 (Linux; U; Android 2.3.7; zh-cn; MB200 Build/GRJ22; CyanogenMod-7) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1&quot;</span>,</span><br><span class="line">    <span class="comment"># Android Opera Mobile</span></span><br><span class="line">    <span class="string">&quot;Opera/9.80 (Android 2.3.4; Linux; Opera Mobi/build-1107180945; U; en-GB) Presto/2.8.149 Version/11.10&quot;</span>,</span><br><span class="line">    <span class="comment"># Android Pad Moto Xoom</span></span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Linux; U; Android 3.0; en-us; Xoom Build/HRI39) AppleWebKit/534.13 (KHTML, like Gecko) Version/4.0 Safari/534.13&quot;</span>,</span><br><span class="line">    <span class="comment"># BlackBerry</span></span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (BlackBerry; U; BlackBerry 9800; en) AppleWebKit/534.1+ (KHTML, like Gecko) Version/6.0.0.337 Mobile Safari/534.1+&quot;</span>,</span><br><span class="line">    <span class="comment"># WebOS HP Touchpad</span></span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (hp-tablet; Linux; hpwOS/3.0.0; U; en-US) AppleWebKit/534.6 (KHTML, like Gecko) wOSBrowser/233.70 Safari/534.6 TouchPad/1.0&quot;</span>,</span><br><span class="line">    <span class="comment"># Nokia N97</span></span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (SymbianOS/9.4; Series60/5.0 NokiaN97-1/20.0.019; Profile/MIDP-2.1 Configuration/CLDC-1.1) AppleWebKit/525 (KHTML, like Gecko) BrowserNG/7.1.18124&quot;</span>,</span><br><span class="line">    <span class="comment"># Windows Phone Mango</span></span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows Phone OS 7.5; Trident/5.0; IEMobile/9.0; HTC; Titan)&quot;</span>,</span><br><span class="line">    <span class="comment"># UC浏览器</span></span><br><span class="line">    <span class="string">&quot;UCWEB7.0.2.37/28/999&quot;</span>,</span><br><span class="line">    <span class="string">&quot;NOKIA5700/ UCWEB7.0.2.37/28/999&quot;</span>,</span><br><span class="line">    <span class="comment"># UCOpenwave</span></span><br><span class="line">    <span class="string">&quot;Openwave/ UCWEB7.0.2.37/28/999&quot;</span>,</span><br><span class="line">    <span class="comment"># UC Opera</span></span><br><span class="line">    <span class="string">&quot;Mozilla/4.0 (compatible; MSIE 6.0; ) Opera/UCWEB7.0.2.37/28/999&quot;</span>,</span><br><span class="line">    <span class="comment"># Opera</span></span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36 OPR/26.0.1656.60&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Opera/8.0 (Windows NT 5.1; U; en)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows NT 5.1; U; en; rv:1.8.1) Gecko/20061208 Firefox/2.0.0 Opera 9.50&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; en) Opera 9.50&quot;</span>,</span><br><span class="line">    <span class="comment"># Firefox</span></span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:34.0) Gecko/20100101 Firefox/34.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (X11; U; Linux x86_64; zh-CN; rv:1.9.2.10) Gecko/20100922 Ubuntu/10.10 (maverick) Firefox/3.6.10&quot;</span>,</span><br><span class="line">    <span class="comment"># Safari</span></span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2&quot;</span>,</span><br><span class="line">    <span class="comment"># chrome</span></span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.133 Safari/534.16&quot;</span>,</span><br><span class="line">    <span class="comment"># 360</span></span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko&quot;</span>,</span><br><span class="line">    <span class="comment"># 淘宝浏览器</span></span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.11 TaoBrowser/2.0 Safari/536.11&quot;</span>,</span><br><span class="line">    <span class="comment"># 猎豹浏览器</span></span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.71 Safari/537.1 LBBROWSER&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; LBBROWSER)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E; LBBROWSER)&quot;</span>,</span><br><span class="line">    <span class="comment"># QQ浏览器</span></span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser/7.0.3698.400)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)&quot;</span>,</span><br><span class="line">    <span class="comment"># sogou浏览器</span></span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.84 Safari/535.11 SE 2.X MetaSr 1.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SV1; QQDownload 732; .NET4.0C; .NET4.0E; SE 2.X MetaSr 1.0)&quot;</span>,</span><br><span class="line">    <span class="comment"># maxthon浏览器</span></span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Maxthon/4.4.3.4000 Chrome/30.0.1599.101 Safari/537.36&quot;</span>,</span><br><span class="line">    <span class="comment"># UC浏览器</span></span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 UBrowser/4.0.3214.0 Safari/537.36&quot;</span>,</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现一个方法, 获取随机User-Agent的请求头</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_request_headers</span>():</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span>: random.choice(USER_AGENTS),</span><br><span class="line">        <span class="string">&quot;accept&quot;</span>: <span class="string">&quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;</span>,</span><br><span class="line">        <span class="string">&quot;accept-language&quot;</span>: <span class="string">&quot;zh-CN,zh;q=0.9,zh-TW;q=0.8,en-US;q=0.7,en;q=0.6&quot;</span>,</span><br><span class="line">        <span class="comment"># &quot;&quot;</span></span><br><span class="line">        <span class="comment"># &quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> headers</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Python自动化测试Unittest框架基本使用</title>
    <url>/lxb/8bbff952.html</url>
    <content><![CDATA[<h1 id="Unittest-框架"><a href="#Unittest-框架" class="headerlink" title="Unittest 框架"></a>Unittest 框架</h1><ul>
<li>首先要知道这个框架是Python自带的, 不需要安装</li>
<li>这个框架最重要的4 个核心<blockquote>
<ol>
<li>TestCase</li>
<li>TestSuite</li>
<li>TextTestRunner</li>
<li>Fixture </li>
</ol>
</blockquote>
<h2 id="TestCase"><a href="#TestCase" class="headerlink" title="TestCase"></a>TestCase</h2></li>
<li>个人总结一下, 这个就是用测试用例继承的, 直接往下看吧</li>
</ul>
<p>学测试先了解断言把</p>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>概念：让程序代替人为判断测试程序执行结果是否符合预期结果的过程</p>
<p><strong>断言分类</strong></p>
<blockquote>
<p>布尔型断言<br>比较断言<br>复杂断言</p>
</blockquote>
<ul>
<li>看完概念再看一下代码吧好了解一点</li>
<li>先写一个简单测试用例,<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestAdd</span>(<span class="params">unittest.TestCase</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_add</span>(<span class="params">self</span>):</span></span><br><span class="line">        a = <span class="number">12</span></span><br><span class="line">        print(<span class="string">&quot;-------- test_add 测试用例-------&quot;</span>)</span><br><span class="line">        b = <span class="number">5</span></span><br><span class="line">        <span class="comment"># assertEqual 这个方法验证arg1=arg2，不相等则fail(报错)</span></span><br><span class="line">        self.assertEqual(a+b, <span class="number">17</span>, msg=<span class="string">&quot;两个数相加,如果不相同会报错&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_sub</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;-------- test_sub 测试用例-------&quot;</span>)</span><br><span class="line">        a = <span class="number">12</span></span><br><span class="line">        b = <span class="number">5</span></span><br><span class="line">        <span class="comment"># assertNotEqual  这个方法验证arg1=arg2，相等则fail(报错)</span></span><br><span class="line">        self.assertNotEqual(a+b, <span class="number">17</span>, msg=<span class="string">&quot;两个数相加, 如果等于17会报错&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">如果执行的时候,没有写main函数, 直接右键执行的时候记得把,鼠标的光标放到函数的外面,</span></span><br><span class="line"><span class="string">如果是放到某个函数里只会执行光标所在的那个测试函数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意点: ==<strong>必须继承unittest.TestCase类, 测试用例的方法必须以 test 开头, 这点很重要</strong>==</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>还有一点就是执行的时候注意:<br>==<strong>如果执行的时候,没有写main函数, 直接右键执行的时候记得把,鼠标的光标放到函数的外面,<br>如果是放到某个函数里只会执行光标所在的那个测试函数</strong>==</p>
</blockquote>
<ul>
<li>这个测试用例只使用了两个布尔型断言,下面列出其他的布尔型断言,使用方法大致一样</li>
</ul>
<table>
<thead>
<tr>
<th>断言方法</th>
<th>断言描述</th>
</tr>
</thead>
<tbody><tr>
<td>assertEqual(arg1, arg2, msg=None)</td>
<td>验证arg1=arg2，不等则fail</td>
</tr>
<tr>
<td>assertNotEqual(arg1, arg2, msg=None)</td>
<td>验证arg1 != arg2, 相等则fail</td>
</tr>
<tr>
<td>assertTrue(expr, msg=None)</td>
<td>验证expr是true，如果为false，则fail</td>
</tr>
<tr>
<td>assertFalse(expr,msg=None)</td>
<td>验证expr是false，如果为true，则fail</td>
</tr>
<tr>
<td>assertIsNone(expr, msg=None)</td>
<td>验证expr是None，不是则fail</td>
</tr>
<tr>
<td>assertIsNotNone(expr, msg=None)</td>
<td>验证expr不是None，是则fail</td>
</tr>
<tr>
<td>assertIn(arg1, arg2, msg=None)</td>
<td>验证arg1是arg2的子串，不是则fail</td>
</tr>
</tbody></table>
<blockquote>
<p>mag: 就是显示报错的描述</p>
</blockquote>
<hr>
<h2 id="Fixture"><a href="#Fixture" class="headerlink" title="Fixture"></a>Fixture</h2><ul>
<li>这就是一个概述，对一个测试用例环境的搭建和销毁就是一个Fixture</li>
<li>不是很理解是吧, 直接看代码(个人觉得没必要理解这个名词,知道是干什么的就行)</li>
<li>把下面代码写入到 test_unittest.py文件下<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestAdd</span>(<span class="params">unittest.TestCase</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        方法名固定，在每个测试函数执行前，执行一次,多个测试函数，执行多次</span></span><br><span class="line"><span class="string">        一般做初始化工作, 比如: 实例化一个浏览器、浏览器最大化、隐式等待设置等需要提前的操作</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        print(<span class="string">&quot;测试函数前执行&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        方法名固定，在每个测试函数执行后，执行一次</span></span><br><span class="line"><span class="string">        一般做结束工作: 比如: 推出浏览器、关闭浏览器</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        print(<span class="string">&quot;测试函数执行后 teardown&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_add</span>(<span class="params">self</span>):</span></span><br><span class="line">        a = <span class="number">12</span></span><br><span class="line">        print(<span class="string">&quot;-------- test_add 测试用例-------&quot;</span>)</span><br><span class="line">        b = <span class="number">5</span></span><br><span class="line">        self.assertEqual(a+b, <span class="number">17</span>, msg=<span class="string">&quot;两个数相加,如果不相同会报错&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_sub</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;-------- test_sub 测试用例-------&quot;</span>)</span><br><span class="line">        a = <span class="number">12</span></span><br><span class="line">        b = <span class="number">5</span></span><br><span class="line">        self.assertNotEqual(a+b, <span class="number">17</span>, msg=<span class="string">&quot;两个数相加, 如果等于17会报错&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">使用主函数,调用unittest.main()方法直接执行改文件下的所有测试用例</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    unittest.main()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>看到代码, 是不是多啦两个方法setUp(self) ,tearDown(self)<br>setUp、tearDown就是一个Fixture</p>
</blockquote>
</li>
</ul>
<p>下面讲述第三种执行的方法: 使用run文件执行<br>创建一个run_unittest.py 文件, 这个文件用来执行其它文件的测试用例<br>看代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="comment"># 直接导入刚才写好的测试类</span></span><br><span class="line"><span class="keyword">from</span> test_unittest <span class="keyword">import</span> TestAdd</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">使用run文件执行unittest 文件时, 可以直接导入</span></span><br><span class="line"><span class="string">这时 unittest 会自动查找导入问价中类去执行</span></span><br><span class="line"><span class="string">但是文件的开头以test 文件的类和函数也必须以test开头</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure>

<h2 id="TestSuite-和-TextTestRunner"><a href="#TestSuite-和-TextTestRunner" class="headerlink" title="TestSuite 和 TextTestRunner"></a>TestSuite 和 TextTestRunner</h2><ul>
<li>我是使用run 文件 写的, 创建一个执行文件, 话不多说, 直接看代码, 注释就是解释</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> test_unittest <span class="keyword">import</span> TestAdd</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">使用run文件执行unittest 文件时, 可以直接导入</span></span><br><span class="line"><span class="string">这时 unittest 会自动查找导入问价中类去执行</span></span><br><span class="line"><span class="string">但是文件的开头以test 文件的类和函数也必须以test开头</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    TestSuite   可以把这个方法看成一个测试集合</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 先创建一个 TestSuite 的实例化对象</span></span><br><span class="line">    suite = unittest.TestSuite()</span><br><span class="line">    <span class="comment"># 然后在使用 addTest方法把写好的测试用例放到这个对象里</span></span><br><span class="line">    <span class="comment"># suite.addTest(测试类名(&quot;方法名&quot;)) # 单个添加</span></span><br><span class="line">    <span class="comment"># suite.addTests([测试类名(&quot;方法名&quot;),测试类名(&quot;方法名&quot;),...])  # 批量添加</span></span><br><span class="line">    suite.addTest(TestAdd(<span class="string">&quot;test_add&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    TextTestRunner  有创建测试集合的方法,肯定就有执行测试集合的方法</span></span><br><span class="line"><span class="string">    TextTestRunner 就是用来执行测试集合的</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 先实例化一个执行集合的 TextTestRunner对象</span></span><br><span class="line">    runner = unittest.TextTestRunner()</span><br><span class="line">    <span class="comment"># 然后执行:  执行对象.run(测试集对象)</span></span><br><span class="line">    runner.run(suite)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="defaultTestLoader-使用"><a href="#defaultTestLoader-使用" class="headerlink" title="defaultTestLoader 使用"></a>defaultTestLoader 使用</h3><ul>
<li>先说一下, 我的测试用例 和 执行文件是在一个目录下的, 直接看代码</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">使用run文件执行unittest 文件时, 可以直接导入</span></span><br><span class="line"><span class="string">这时 unittest 会自动查找导入问价中类去执行</span></span><br><span class="line"><span class="string">但是文件的开头以test 文件的类和函数也必须以test开头</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    defaultTestLoader</span></span><br><span class="line"><span class="string">    使用unittest.defaultTestLoader()类, 这个类的作用就是,调用这个类的discover()方法, 搜索指定目录下指定开头的.py文件,</span></span><br><span class="line"><span class="string">    并将搜索到的测试用例组装成一个测试集合, 听上去是不是和 TestSuite 的作用差不多</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 先确定一个要搜索的路径</span></span><br><span class="line">    test_dir = <span class="string">&quot;./&quot;</span></span><br><span class="line">    <span class="comment"># 然后创建集合对象</span></span><br><span class="line">    dis = unittest.defaultTestLoader.discover(test_dir, pattern=<span class="string">&#x27;test_*.py&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 然后使用 TextTestRunner 运行这个测试集合</span></span><br><span class="line">    runner = unittest.TextTestRunner()</span><br><span class="line">    runner.run(dis)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Python自动化测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Python自动化测试(unittest)使用BeautifulReport和HTMLTestRunner生成HTML测试报告</title>
    <url>/lxb/e321baf5.html</url>
    <content><![CDATA[<h1 id="HTML测试报告"><a href="#HTML测试报告" class="headerlink" title="HTML测试报告"></a>HTML测试报告</h1><p>HTML 测试报告就是执行完测试用例后以网页的方式显示执行的结果</p>
<h2 id="HTML-生成报告的方式"><a href="#HTML-生成报告的方式" class="headerlink" title="HTML 生成报告的方式"></a>HTML 生成报告的方式</h2><h3 id="1-BeautifulReport"><a href="#1-BeautifulReport" class="headerlink" title="1. BeautifulReport"></a>1. BeautifulReport</h3><p>安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install BeautifulReport</span><br></pre></td></tr></table></figure>
<p>先写测试用例, 基本测试用例介绍看上一篇<a href="https://blog.csdn.net/lxb_wyf/article/details/109146665">unittest编写测试用例基本使用</a><br>看代码, 先创建一个test_unittest.py文件,用来编写测试用例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> BeautifulReport <span class="keyword">import</span> BeautifulReport</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">编写测试用例</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestAdd</span>(<span class="params">unittest.TestCase</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        方法名固定，在每个测试函数执行前，执行一次,多个测试函数，执行多次</span></span><br><span class="line"><span class="string">        一般做初始化工作, 比如: 实例化一个浏览器、浏览器最大化、隐式等待设置等需要提前的操作</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        print(<span class="string">&quot;测试函数前执行&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        方法名固定，在每个测试函数执行后，执行一次</span></span><br><span class="line"><span class="string">        一般做结束工作: 比如: 推出浏览器、关闭浏览器</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        print(<span class="string">&quot;测试函数执行后 teardown&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_add</span>(<span class="params">self</span>):</span></span><br><span class="line">        a = <span class="number">12</span></span><br><span class="line">        print(<span class="string">&quot;-------- test_add 测试用例-------&quot;</span>)</span><br><span class="line">        b = <span class="number">5</span></span><br><span class="line">        self.assertEqual(a+b, <span class="number">17</span>, msg=<span class="string">&quot;两个数相加,如果不相同会报错&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_sub</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;-------- test_sub 测试用例-------&quot;</span>)</span><br><span class="line">        a = <span class="number">12</span></span><br><span class="line">        b = <span class="number">5</span></span><br><span class="line">        self.assertNotEqual(a+b, <span class="number">17</span>, msg=<span class="string">&quot;两个数相加, 如果等于17会报错&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后编写 执行文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> BeautifulReport <span class="keyword">import</span> BeautifulReport</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    生成测试报告 BeautifulReport</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 先确定一个要搜索的路径</span></span><br><span class="line">    test_dir = <span class="string">&quot;./&quot;</span></span><br><span class="line">    <span class="comment"># 然后创建集合对象</span></span><br><span class="line">    dis = unittest.defaultTestLoader.discover(test_dir, pattern=<span class="string">&#x27;test_*.py&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    runner = BeautifulReport(dis)</span><br><span class="line">    runner.report(</span><br><span class="line">        description=<span class="string">&quot;描述信息&quot;</span>,</span><br><span class="line">        filename=<span class="string">&quot;BeautifulReport&quot;</span>  <span class="comment"># 生成测试报告的文件名</span></span><br><span class="line">    )</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行后打开生成的的HTML</p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/20201019111724767.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4Yl93eWY=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
<h3 id="HTMLTestRunner"><a href="#HTMLTestRunner" class="headerlink" title="HTMLTestRunner"></a>HTMLTestRunner</h3><p>编写执行文件,代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> HTMLTestRunner.HTMLTestRunner <span class="keyword">import</span> HTMLTestRunner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    生成测试报告</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 先确定一个要搜索的路径</span></span><br><span class="line">    test_dir = <span class="string">&quot;./&quot;</span></span><br><span class="line">    <span class="comment"># 然后创建集合对象</span></span><br><span class="line">    dis = unittest.defaultTestLoader.discover(test_dir, pattern=<span class="string">&#x27;test_*.py&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&quot;test.html&quot;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        runner = HTMLTestRunner(</span><br><span class="line">            <span class="comment"># 执行的文件</span></span><br><span class="line">            stream=f,</span><br><span class="line">            title=<span class="string">&quot;测试的标题&quot;</span>,</span><br><span class="line">            description=<span class="string">&quot;测试的描述信息&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        runner.run(dis)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行后打开生成的的HTML</p>
<ul>
<li><img src="https://img-blog.csdnimg.cn/20201019111819714.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4Yl93eWY=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
]]></content>
      <tags>
        <tag>Python自动化测试</tag>
      </tags>
  </entry>
  <entry>
    <title>unittest+selenium编写一个简单的自动化测试用例</title>
    <url>/lxb/10659ea7.html</url>
    <content><![CDATA[<h2 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例 1"></a>测试用例 1</h2><ul>
<li>测试对象: B站 (B站登录)  <a href="https://passport.bilibili.com/login">https://passport.bilibili.com/login</a></li>
<li>只简单测试了登录功能,而且还没完善, 没完善的内容是, B站登录需要一个验证码, 我这点没有实现, 所以是选择手动点击图片验证码,下面还有一个GitHub的登录测试用例, GitHub登录时不需要验证码</li>
<li>分析b站的登录网页的数据结构</li>
<li>输入账号的文本框<img src="https://img-blog.csdnimg.cn/20201020140016856.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4Yl93eWY=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>输入密码的文本框<img src="https://img-blog.csdnimg.cn/20201020140101656.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4Yl93eWY=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>登录的点击按钮<img src="https://img-blog.csdnimg.cn/20201020140133240.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4Yl93eWY=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>先创建一个测试用例文件 test_bilibili.py 文件,在里面编写测试用例<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">测试用例</span></span><br><span class="line"><span class="string">测试对象: B站 (B站登录)  https://passport.bilibili.com/login</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> parameterized <span class="keyword">import</span> parameterized</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestLogin</span>(<span class="params">unittest.TestCase</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    1. 打开浏览器   :  就使用 setUp(self)方法打开浏览器</span></span><br><span class="line"><span class="string">    2. 查找用户名输入框</span></span><br><span class="line"><span class="string">    3. 查找密码的输入框</span></span><br><span class="line"><span class="string">    4. 点击登录</span></span><br><span class="line"><span class="string">    5. 断言登录成功与否  使用登录后的页面上的用户名进行断言</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="comment"># 创建一个浏览器对象</span></span><br><span class="line">        self.driver = webdriver.Chrome(<span class="string">&quot;../chromedriver.exe&quot;</span>)</span><br><span class="line">        <span class="comment"># 发送请求</span></span><br><span class="line">        self.driver.get(<span class="string">&quot;https://passport.bilibili.com/login&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.driver.close()  <span class="comment"># 关闭浏览器</span></span><br><span class="line">        self.driver.quit()  <span class="comment"># 退出浏览器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_login</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 创建账号登录信息</span></span><br><span class="line">        username = <span class="string">&quot;这里输入你的账号&quot;</span></span><br><span class="line">        password = <span class="string">&quot;这里输入你的密码&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 查找输入账号的文本框, 并输入账号</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        self.driver.find_element_by_id(<span class="string">&quot;login-username&quot;</span>).clear()  <span class="comment"># 先清空文本框内容</span></span><br><span class="line">        self.driver.find_element_by_id(<span class="string">&quot;login-username&quot;</span>).send_keys(username)  <span class="comment"># 输入账号</span></span><br><span class="line">        <span class="comment"># 查找出入密码的文本框, 并输入密码</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        self.driver.find_element_by_id(<span class="string">&quot;login-passwd&quot;</span>).clear()  <span class="comment"># 先清空文本框的内容</span></span><br><span class="line">        self.driver.find_element_by_id(<span class="string">&quot;login-passwd&quot;</span>).send_keys(password)  <span class="comment"># 输入密码</span></span><br><span class="line">        <span class="comment"># 查找登录的按钮, 点击登录</span></span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        self.driver.find_element_by_class_name(<span class="string">&quot;btn-login&quot;</span>).click()</span><br><span class="line">        <span class="comment"># 代码写到一半, 我发现登录需要一个图片验证码, 所以我决定图片验证码手动点一下, 这里延迟 10 秒进行手动点击</span></span><br><span class="line">        time.sleep(<span class="number">10</span>)</span><br><span class="line">        <span class="comment"># 断言登录是否成功</span></span><br><span class="line">        handle = self.driver.current_window_handle</span><br><span class="line">        self.driver.switch_to.window(handle)</span><br><span class="line">        index = self.driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;primaryPageTab&quot;]/ul/li[1]/a/span&#x27;</span>).text</span><br><span class="line">        self.assertEqual(index, <span class="string">&quot;首页&quot;</span>, msg=<span class="string">&#x27;登录失败&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>然后编写执行文件text_run.py 文件, 用来执行测试用例<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> BeautifulReport <span class="keyword">import</span> BeautifulReport</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">使用run文件执行unittest 文件时, 可以直接导入</span></span><br><span class="line"><span class="string">这时 unittest 会自动查找导入问价中类去执行</span></span><br><span class="line"><span class="string">但是文件的开头以test 文件的类和函数也必须以test开头</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    defaultTestLoader</span></span><br><span class="line"><span class="string">    使用unittest.defaultTestLoader()类, 这个类的作用就是,调用这个类的discover()方法, 搜索指定目录下指定开头的.py文件,</span></span><br><span class="line"><span class="string">    并将搜索到的测试用例组装成一个测试集合, 听上去是不是和 TestSuite 的作用差不多</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 先确定一个要搜索的路径</span></span><br><span class="line">    test_dir = <span class="string">&quot;.&quot;</span></span><br><span class="line">    <span class="comment"># 然后创建集合对象</span></span><br><span class="line">    dis = unittest.defaultTestLoader.discover(test_dir, pattern=<span class="string">&#x27;test_bilibili.py&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    runner = BeautifulReport(dis)</span><br><span class="line">    runner.report(</span><br><span class="line">        description=<span class="string">&quot;b站登录&quot;</span>,</span><br><span class="line">        filename=<span class="string">&quot;bilibili_login&quot;</span>  <span class="comment"># 生成测试报告的文件名</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
这个只能输入一个账号, 看上去很不方便,我在介绍一个很好用的模块, 这个模块就像是一个装饰器<br>先安装<blockquote>
<p>pip install parameterized</p>
</blockquote>
</li>
</ul>
<p>然后把测试用例test_bilibili.py改为如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">测试用例</span></span><br><span class="line"><span class="string">测试对象: B站 (B站登录)  https://passport.bilibili.com/login</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> parameterized <span class="keyword">import</span> parameterized</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestLogin</span>(<span class="params">unittest.TestCase</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    1. 打开浏览器   :  就使用 setUp(self)方法打开浏览器</span></span><br><span class="line"><span class="string">    2. 查找用户名输入框</span></span><br><span class="line"><span class="string">    3. 查找密码的输入框</span></span><br><span class="line"><span class="string">    4. 点击登录</span></span><br><span class="line"><span class="string">    5. 断言登录成功与否  使用登录后的页面上的用户名进行断言</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 创建登录数据, 这里可以写多个账号进行测试</span></span><br><span class="line">    data = [</span><br><span class="line">        (<span class="string">&#x27;账号&#x27;</span>, <span class="string">&#x27;密码&#x27;</span>),</span><br><span class="line">        (<span class="string">&#x27;账号&#x27;</span>, <span class="string">&#x27;密码&#x27;</span>),</span><br><span class="line">        (<span class="string">&#x27;账号&#x27;</span>, <span class="string">&#x27;密码&#x27;</span>),</span><br><span class="line">    ]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="comment"># 创建一个浏览器对象</span></span><br><span class="line">        self.driver = webdriver.Chrome(<span class="string">&quot;../chromedriver.exe&quot;</span>)</span><br><span class="line">        <span class="comment"># 发送请求</span></span><br><span class="line">        self.driver.get(<span class="string">&quot;https://passport.bilibili.com/login&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.driver.close()  <span class="comment"># 关闭浏览器</span></span><br><span class="line">        self.driver.quit()  <span class="comment"># 退出浏览器</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @parameterized.expand(data)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_login</span>(<span class="params">self, username, password</span>):</span></span><br><span class="line">        <span class="comment"># 查找输入账号的文本框, 并输入账号</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        self.driver.find_element_by_id(<span class="string">&quot;login-username&quot;</span>).clear()  <span class="comment"># 先清空文本框内容</span></span><br><span class="line">        self.driver.find_element_by_id(<span class="string">&quot;login-username&quot;</span>).send_keys(username)  <span class="comment"># 输入账号</span></span><br><span class="line">        <span class="comment"># 查找出入密码的文本框, 并输入密码</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        self.driver.find_element_by_id(<span class="string">&quot;login-passwd&quot;</span>).clear()  <span class="comment"># 先清空文本框的内容</span></span><br><span class="line">        self.driver.find_element_by_id(<span class="string">&quot;login-passwd&quot;</span>).send_keys(password)  <span class="comment"># 输入密码</span></span><br><span class="line">        <span class="comment"># 查找登录的按钮, 点击登录</span></span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        self.driver.find_element_by_class_name(<span class="string">&quot;btn-login&quot;</span>).click()</span><br><span class="line">        <span class="comment"># 代码写到一半, 我发现登录需要一个图片验证码, 所以我决定图片验证码手动点一下</span></span><br><span class="line">        time.sleep(<span class="number">10</span>)</span><br><span class="line">        <span class="comment"># 断言登录是否成功</span></span><br><span class="line">        handle = self.driver.current_window_handle</span><br><span class="line">        self.driver.switch_to.window(handle)</span><br><span class="line">        index = self.driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;primaryPageTab&quot;]/ul/li[1]/a/span&#x27;</span>).text</span><br><span class="line">        <span class="comment">#  # 进行断言, 如果在登录后的界面出现&quot;首页&quot;二字,就代表成功.否则视为失败</span></span><br><span class="line">        self.assertEqual(index, <span class="string">&quot;首页&quot;</span>, msg=<span class="string">&#x27;登录失败&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>整个测试的流程已经写完了, 有很大的瑕疵, 就在没有完成自动点击图片验证, 直接看下一个吧<h2 id="测试用例-2"><a href="#测试用例-2" class="headerlink" title="测试用例 2"></a>测试用例 2</h2></li>
<li>测试对象: GitHub (登录)  <a href="https://github.com/login">https://github.com/login</a></li>
<li>先分析网页结构,查找登录时账号的文本输入框</li>
<li><img src="https://img-blog.csdnimg.cn/20201020150140252.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4Yl93eWY=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>在定位密码的输入文本框</li>
<li><img src="https://img-blog.csdnimg.cn/20201020150223788.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4Yl93eWY=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>在 定位登录按钮</li>
<li><img src="https://img-blog.csdnimg.cn/20201020150346879.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4Yl93eWY=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>登录成功后进行断言, 如果在登录后的界面出现你的用户名,就代表成功.否则视为失败</li>
<li><img src="https://img-blog.csdnimg.cn/202010201504531.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4Yl93eWY=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201020150506793.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4Yl93eWY=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>创建测试用例文件 test_git.py<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">测试用例</span></span><br><span class="line"><span class="string">测试对象: github  https://github.com/login</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> parameterized <span class="keyword">import</span> parameterized</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestLogin</span>(<span class="params">unittest.TestCase</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    1. 打开浏览器   :  就使用 setUp(self)方法打开浏览器</span></span><br><span class="line"><span class="string">    2. 查找用户名输入框</span></span><br><span class="line"><span class="string">    3. 查找密码的输入框</span></span><br><span class="line"><span class="string">    4. 点击登录</span></span><br><span class="line"><span class="string">    5. 断言登录成功与否  使用登录后的页面上的用户名进行断言</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 创建登录数据</span></span><br><span class="line">    data = [</span><br><span class="line">        (<span class="string">&quot;账号&quot;</span>, <span class="string">&quot;密码&quot;</span>),</span><br><span class="line">        (<span class="string">&#x27;sssssss-dss&#x27;</span>, <span class="string">&#x27;nisshui1&#x27;</span>),</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="comment"># 创建一个浏览器对象</span></span><br><span class="line">        self.driver = webdriver.Chrome(<span class="string">&quot;../chromedriver.exe&quot;</span>)</span><br><span class="line">        <span class="comment"># 发送请求</span></span><br><span class="line">        self.driver.get(<span class="string">&quot;https://github.com/login&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.driver.close()  <span class="comment"># 关闭浏览器</span></span><br><span class="line">        self.driver.quit()  <span class="comment"># 退出浏览器</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @parameterized.expand(data)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_login</span>(<span class="params">self, username, password</span>):</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        self.driver.find_element_by_id(<span class="string">&quot;login_field&quot;</span>).clear()  <span class="comment"># 先清空文本框内容</span></span><br><span class="line">        self.driver.find_element_by_id(<span class="string">&quot;login_field&quot;</span>).send_keys(username)  <span class="comment"># 输入账号</span></span><br><span class="line">        <span class="comment"># 查找出入密码的文本框, 并输入密码</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        self.driver.find_element_by_id(<span class="string">&quot;password&quot;</span>).clear()  <span class="comment"># 先清空文本框的内容</span></span><br><span class="line">        self.driver.find_element_by_id(<span class="string">&quot;password&quot;</span>).send_keys(password)  <span class="comment"># 输入密码</span></span><br><span class="line">        <span class="comment"># 查找登录的按钮, 点击登录</span></span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        self.driver.find_element_by_class_name(<span class="string">&quot;btn-primary&quot;</span>).click()</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 断言登录是否成功</span></span><br><span class="line">        handle = self.driver.current_window_handle</span><br><span class="line">        self.driver.switch_to.window(handle)</span><br><span class="line">        index = self.driver.find_element_by_xpath(<span class="string">&quot;//span[@class=&#x27;flex-shrink-0 css-truncate css-truncate-target&#x27;]&quot;</span>).text</span><br><span class="line">        <span class="comment"># 进行断言, 如果在登录后的界面出现你的用户名,就代表成功.否则视为失败</span></span><br><span class="line">        self.assertEqual(index, username, msg=<span class="string">&#x27;登录失败&#x27;</span>)</span><br></pre></td></tr></table></figure>
编写执行文件 test_git_run.py <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> BeautifulReport <span class="keyword">import</span> BeautifulReport</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">使用run文件执行unittest 文件时, 可以直接导入</span></span><br><span class="line"><span class="string">这时 unittest 会自动查找导入问价中类去执行</span></span><br><span class="line"><span class="string">但是文件的开头以test 文件的类和函数也必须以test开头</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    defaultTestLoader</span></span><br><span class="line"><span class="string">    使用unittest.defaultTestLoader()类, 这个类的作用就是,调用这个类的discover()方法, 搜索指定目录下指定开头的.py文件,</span></span><br><span class="line"><span class="string">    并将搜索到的测试用例组装成一个测试集合, 听上去是不是和 TestSuite 的作用差不多</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 先确定一个要搜索的路径</span></span><br><span class="line">    test_dir = <span class="string">&quot;.&quot;</span></span><br><span class="line">    <span class="comment"># 然后创建集合对象</span></span><br><span class="line">    dis = unittest.defaultTestLoader.discover(test_dir, pattern=<span class="string">&#x27;test_git.py&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    runner = BeautifulReport(dis)</span><br><span class="line">    runner.report(</span><br><span class="line">        description=<span class="string">&quot;Github 登录&quot;</span>,</span><br><span class="line">        filename=<span class="string">&quot;Github_login&quot;</span>  <span class="comment"># 生成测试报告的文件名</span></span><br><span class="line">    )</span><br><span class="line"></span><br></pre></td></tr></table></figure>
我只使用了两个账号信息, 一对一错, 测试报告如下<br><img src="https://img-blog.csdnimg.cn/20201020150928611.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4Yl93eWY=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
]]></content>
      <tags>
        <tag>Python自动化测试</tag>
      </tags>
  </entry>
</search>
