<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Python十大算法之选择排序Python代码简单实现</title>
    <url>/lxb/30363e5e.html</url>
    <content><![CDATA[<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><img src="https://img-blog.csdnimg.cn/20201014210457815.gif#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">(不考虑列表元素小于1的列表,如果列表小于等于1,需要捕获异常)</span></span><br><span class="line"><span class="string">选择排序是记录最小值的下标</span></span><br><span class="line"><span class="string">先拿着一个元素进行元素对比,找到最小的元素,把这个最小的元素放到最前面,然后在从剩余的元素中继续</span></span><br><span class="line"><span class="string">寻找最小的元素,然后放在已经排序过的序列末尾</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_list</span>(<span class="params">list_</span>):</span></span><br><span class="line">    <span class="comment"># 先定义比较的轮数, 一个一个的比较,所以省去最后一次,总轮数为 元素个数减 1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(list_)<span class="number">-1</span>):</span><br><span class="line">        <span class="comment"># 定义一个最小元素的下标,(如果是降序就是最大元素的下标)</span></span><br><span class="line">        min_sub = i</span><br><span class="line">        <span class="comment"># 定义每轮的要进行比较的次数, 由于每轮比较后都会固定一个元素,所以每轮比较次数为 总元素个数减去轮次</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(len(list_) -i):</span><br><span class="line">            <span class="keyword">if</span> list_[min_sub] &gt; list_[n+i]:</span><br><span class="line">                min_sub = n+i</span><br><span class="line">        list_[i], list_[min_sub] = list_[min_sub], list_[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list_</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    list_num = [<span class="number">23</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">78</span>, <span class="number">56</span>, <span class="number">55</span>, <span class="number">77</span>, <span class="number">8</span>, <span class="number">2</span>]</span><br><span class="line">    print(sort_list(list_num))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Python 算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Python十大算法之冒泡排序python代码简单实现</title>
    <url>/lxb/4e54f701.html</url>
    <content><![CDATA[<h2 id="Python-十大算法之冒泡排序"><a href="#Python-十大算法之冒泡排序" class="headerlink" title="(Python)十大算法之冒泡排序!"></a>(Python)十大算法之冒泡排序!</h2><p><img src="https://img-blog.csdnimg.cn/20201014202514264.gif#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">冒泡排序核心:</span></span><br><span class="line"><span class="string">        两个两个数进行比较,小的放前边大的放后面（升序排序降序反之)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 定义一个函数,实现冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_the</span>(<span class="params">list_</span>):</span></span><br><span class="line">    <span class="comment"># 由于需要两个两个的进行元素比较,每次比较都会把最大的一个值放到最后面,最后一轮比较可以省去,所以需要比较的次数为列表元素总数减一</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(list_) - <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 每次进行一轮比较后,会把最大的元素放到最后,所以每轮进比较的次数为 总轮数 - 当前轮次</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range((len(list_) - <span class="number">1</span> - i)):</span><br><span class="line">        	<span class="comment"># 该排序是大的在后面, 如果需要大的在前面,把大于号改为小于号</span></span><br><span class="line">            <span class="keyword">if</span> list_[n] &gt; list_[n + <span class="number">1</span>]:</span><br><span class="line">                list_[n], list_[n + <span class="number">1</span>] = list_[n + <span class="number">1</span>], list_[n]</span><br><span class="line">    <span class="keyword">return</span> list_</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    list_num = [<span class="number">23</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">78</span>, <span class="number">56</span>, <span class="number">55</span>, <span class="number">77</span>, <span class="number">8</span>, <span class="number">2</span>]</span><br><span class="line">    print(sort_the(list_num))</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Python 算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Python装饰器代码简单实现带参数不带参数计算时间</title>
    <url>/lxb/cb3133ae.html</url>
    <content><![CDATA[<h1 id="Python装饰器代码简单实现"><a href="#Python装饰器代码简单实现" class="headerlink" title="Python装饰器代码简单实现"></a>Python装饰器代码简单实现</h1><hr>
<p>先说一说装饰器的个人理解吧</p>
<ul>
<li>装饰器就是在不改变原函数的情况下,给原函数增加一些额外的功能,装饰器本质就是一个闭包(先说这么多,以后再补充)<h2 id="不接受参数的通用装饰器"><a href="#不接受参数的通用装饰器" class="headerlink" title="不接受参数的通用装饰器"></a>不接受参数的通用装饰器</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">定义一个装饰器,这是一个不接受参数的装饰器</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="comment"># 加 *args, **kwargs 这两个参数为了能够接受参入函数的参数(你不能保证传入的函数有没有参数,以及这个传入的函数有多少个参数)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&quot;我是装饰器&quot;</span>)</span><br><span class="line">        fun = func(*args, **kwargs)</span><br><span class="line">        <span class="comment"># 最后再把传入的函数返回出去</span></span><br><span class="line">        <span class="keyword">return</span> fun</span><br><span class="line">    <span class="comment"># 这个return 很重要,装饰器就语法就是这样, 返回内部函数,其实装饰器本质就是一个闭包</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">下面是装饰器的使用</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span>():</span></span><br><span class="line">    print(<span class="string">&quot;我是一个函数&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> 执行函数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    function()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="可以接收参数的装饰器"><a href="#可以接收参数的装饰器" class="headerlink" title="可以接收参数的装饰器"></a>可以接收参数的装饰器</h2><p>我这里就写一个只接收一个参数的装饰器, 如果需要多个参数, 只需要再加上就好啦(不懂就留言评论,看到就回)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">定义一个装饰器,这是一个不接受参数的装饰器</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parameter_deco</span>(<span class="params">item</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="comment"># 加 *args, **kwargs 这两个参数为了能够接受参入函数的参数(你不能保证传入的函数有没有参数,以及这个传入的函数有多少个参数)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            print(<span class="string">&quot;我是装饰器&quot;</span>)</span><br><span class="line">            print(<span class="string">&quot;********* 我是装饰器传入的参数 %s **********&quot;</span> % item)</span><br><span class="line">            fun = func(*args, **kwargs)</span><br><span class="line">            <span class="comment"># 最后再把传入的函数返回出去</span></span><br><span class="line">            <span class="keyword">return</span> fun</span><br><span class="line">        <span class="comment"># 这个return 很重要,装饰器就语法就是这样, 返回内部函数,其实装饰器本质就是一个闭包</span></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 看到这里你是不是发现,带有参数的装饰器,就比上面那个不带参数的装饰器多了一层外部函数,外部函数用来接收参数,然后再把内层函数返回</span></span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">下面是装饰器的使用</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里就传入一个值就行(这里我传入一个字符串,这是我的个人博客网站,欢迎访问)</span></span><br><span class="line"><span class="meta">@parameter_deco(&quot;https://lxb-log.github.io/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span>():</span></span><br><span class="line">    print(<span class="string">&quot;我是一个函数&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> 执行函数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    function()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用装饰器实现测试某函数的执行时间"><a href="#使用装饰器实现测试某函数的执行时间" class="headerlink" title="使用装饰器实现测试某函数的执行时间"></a>使用装饰器实现测试某函数的执行时间</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_decorator</span>(<span class="params">func</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 执行传入的函数的开始时间</span></span><br><span class="line">        begin = time.time()</span><br><span class="line">        <span class="comment"># 执行传入的函数</span></span><br><span class="line">        fun = func(*args, **kwargs)</span><br><span class="line">        <span class="comment"># 执行传入的函数的结束时间</span></span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">&quot;该函数执行花费%s&quot;</span> % (end-begin))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fun</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里就传入一个字符串就行(这是我的个人博客网站,欢迎访问)</span></span><br><span class="line"><span class="meta">@time_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span>():</span></span><br><span class="line">    <span class="comment"># time.sleep(2) 延迟2秒,跟容易理解</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">&quot;https://lxb-log.github.io/&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> 执行函数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    function()</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python十大算法之插入排序Python代码简单实现</title>
    <url>/lxb/df95721d.html</url>
    <content><![CDATA[<h1 id="Python十大算法之插入排序Python代码简单实现"><a href="#Python十大算法之插入排序Python代码简单实现" class="headerlink" title="Python十大算法之插入排序Python代码简单实现"></a>Python十大算法之插入排序Python代码简单实现</h1><p><img src="https://img-blog.csdnimg.cn/20201017110805885.gif#pic_center" alt="在这里插入图片描述"></p>
<p><strong><code>图片上是从已排好序的元素最大坐标开始比较的, 我的代码是从已排好序的元素的最小坐标开始,一个道理的</code></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">插入排序 (个人理解)</span></span><br><span class="line"><span class="string">先假设第一个元素不动,从第二个元素开始,然后拿着第二个元素跟第一个(已经排好序的元素)进行对比,</span></span><br><span class="line"><span class="string">如果大于第一个元素就把这个元素放在第一个元素后面,现在已经排好两个元素了</span></span><br><span class="line"><span class="string">接着在拿第三个元素,跟已经排好序的元素进行对比,</span></span><br><span class="line"><span class="string">如果该元素遇到比它小的元素就放在它的后面, 以此类推</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_list</span>(<span class="params">list_</span>):</span></span><br><span class="line">    <span class="comment"># 先定义比较的轮数, 由于是从第二个元素开始的,所以轮数为 总元素个数减 1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(list_)<span class="number">-1</span>):</span><br><span class="line">        <span class="comment"># 然后再定义每轮进行比较的次数,这个次数就是已经排好序的元素个数,每轮排好一个,默认排好一个, 所以次数就是轮次加 1</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span> + i):</span><br><span class="line">            <span class="comment"># 下面开始判断条件,</span></span><br><span class="line">            <span class="keyword">if</span> list_[i+<span class="number">1</span>] &lt; list_[n]:</span><br><span class="line">                list_[i+<span class="number">1</span>], list_[n] = list_[n],  list_[i+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list_</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    list_num = [<span class="number">23</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">78</span>, <span class="number">56</span>, <span class="number">55</span>, <span class="number">77</span>, <span class="number">8</span>, <span class="number">2</span>]</span><br><span class="line">    print(sort_list(list_num))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Python 算法</tag>
      </tags>
  </entry>
</search>
